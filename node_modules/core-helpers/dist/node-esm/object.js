import lodashIsPlainObject from 'lodash/isPlainObject';
import lodashIsObjectLike from 'lodash/isObjectLike';
export function hasOwnProperty(object, key) {
    return _hasOwnProperty.call(object, key);
}
const _hasOwnProperty = Object.prototype.hasOwnProperty;
export function isPrototypeOf(object, other) {
    return _isPrototypeOf.call(object, other);
}
const _isPrototypeOf = Object.prototype.isPrototypeOf;
export function propertyIsEnumerable(object, key) {
    return _propertyIsEnumerable.call(object, key);
}
const _propertyIsEnumerable = Object.prototype.propertyIsEnumerable;
export function getPropertyDescriptor(object, key) {
    if (!((typeof object === 'object' && object !== null) || typeof object === 'function')) {
        return undefined;
    }
    if (!(key in object)) {
        return undefined;
    }
    while (object !== null) {
        const descriptor = Object.getOwnPropertyDescriptor(object, key);
        if (descriptor) {
            return descriptor;
        }
        object = Object.getPrototypeOf(object);
    }
    return undefined;
}
export function getInheritedPropertyDescriptor(object, key) {
    const prototype = Object.getPrototypeOf(object);
    return getPropertyDescriptor(prototype, key);
}
export function isObjectLike(value) {
    return lodashIsObjectLike(value);
}
export function isPlainObject(value) {
    return lodashIsPlainObject(value);
}
export function assertIsObjectLike(value) {
    if (!isObjectLike(value)) {
        throw new Error(`Expected an object-like, but received a value of type '${typeof value}'`);
    }
}
export function assertIsPlainObject(value) {
    if (!isPlainObject(value)) {
        throw new Error(`Expected a plain object, but received a value of type '${typeof value}'`);
    }
}
export const breakSymbol = Symbol('break');
export function forEachDeep(value, iteratee, { _nameOrIndex, _objectOrArray } = {}) {
    const isObject = isPlainObject(value);
    const isArray = Array.isArray(value);
    if (!(isObject || isArray)) {
        return iteratee(value, _nameOrIndex, _objectOrArray);
    }
    if (isObject) {
        const object = value;
        for (const [name, value] of Object.entries(object)) {
            const result = forEachDeep(value, iteratee, { _nameOrIndex: name, _objectOrArray: object });
            if (result === breakSymbol) {
                return breakSymbol;
            }
        }
    }
    if (isArray) {
        const array = value;
        for (const [index, value] of array.entries()) {
            const result = forEachDeep(value, iteratee, { _nameOrIndex: index, _objectOrArray: array });
            if (result === breakSymbol) {
                return breakSymbol;
            }
        }
    }
    return undefined;
}
export function someDeep(value, predicate) {
    const result = forEachDeep(value, function (value) {
        return predicate(value) ? breakSymbol : undefined;
    });
    return result === breakSymbol;
}
export function deleteUndefinedProperties(value) {
    forEachDeep(value, function (value, nameOrIndex, objectOrArray) {
        if (value === undefined &&
            nameOrIndex !== undefined &&
            objectOrArray !== undefined &&
            !Array.isArray(objectOrArray)) {
            delete objectOrArray[nameOrIndex];
        }
    });
    return value;
}
//# sourceMappingURL=object.js.map