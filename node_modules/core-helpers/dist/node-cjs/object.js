"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deleteUndefinedProperties = exports.someDeep = exports.forEachDeep = exports.breakSymbol = exports.assertIsPlainObject = exports.assertIsObjectLike = exports.isPlainObject = exports.isObjectLike = exports.getInheritedPropertyDescriptor = exports.getPropertyDescriptor = exports.propertyIsEnumerable = exports.isPrototypeOf = exports.hasOwnProperty = void 0;
const tslib_1 = require("tslib");
const isPlainObject_1 = tslib_1.__importDefault(require("lodash/isPlainObject"));
const isObjectLike_1 = tslib_1.__importDefault(require("lodash/isObjectLike"));
function hasOwnProperty(object, key) {
    return _hasOwnProperty.call(object, key);
}
exports.hasOwnProperty = hasOwnProperty;
const _hasOwnProperty = Object.prototype.hasOwnProperty;
function isPrototypeOf(object, other) {
    return _isPrototypeOf.call(object, other);
}
exports.isPrototypeOf = isPrototypeOf;
const _isPrototypeOf = Object.prototype.isPrototypeOf;
function propertyIsEnumerable(object, key) {
    return _propertyIsEnumerable.call(object, key);
}
exports.propertyIsEnumerable = propertyIsEnumerable;
const _propertyIsEnumerable = Object.prototype.propertyIsEnumerable;
function getPropertyDescriptor(object, key) {
    if (!((typeof object === 'object' && object !== null) || typeof object === 'function')) {
        return undefined;
    }
    if (!(key in object)) {
        return undefined;
    }
    while (object !== null) {
        const descriptor = Object.getOwnPropertyDescriptor(object, key);
        if (descriptor) {
            return descriptor;
        }
        object = Object.getPrototypeOf(object);
    }
    return undefined;
}
exports.getPropertyDescriptor = getPropertyDescriptor;
function getInheritedPropertyDescriptor(object, key) {
    const prototype = Object.getPrototypeOf(object);
    return getPropertyDescriptor(prototype, key);
}
exports.getInheritedPropertyDescriptor = getInheritedPropertyDescriptor;
function isObjectLike(value) {
    return isObjectLike_1.default(value);
}
exports.isObjectLike = isObjectLike;
function isPlainObject(value) {
    return isPlainObject_1.default(value);
}
exports.isPlainObject = isPlainObject;
function assertIsObjectLike(value) {
    if (!isObjectLike(value)) {
        throw new Error(`Expected an object-like, but received a value of type '${typeof value}'`);
    }
}
exports.assertIsObjectLike = assertIsObjectLike;
function assertIsPlainObject(value) {
    if (!isPlainObject(value)) {
        throw new Error(`Expected a plain object, but received a value of type '${typeof value}'`);
    }
}
exports.assertIsPlainObject = assertIsPlainObject;
exports.breakSymbol = Symbol('break');
function forEachDeep(value, iteratee, { _nameOrIndex, _objectOrArray } = {}) {
    const isObject = isPlainObject(value);
    const isArray = Array.isArray(value);
    if (!(isObject || isArray)) {
        return iteratee(value, _nameOrIndex, _objectOrArray);
    }
    if (isObject) {
        const object = value;
        for (const [name, value] of Object.entries(object)) {
            const result = forEachDeep(value, iteratee, { _nameOrIndex: name, _objectOrArray: object });
            if (result === exports.breakSymbol) {
                return exports.breakSymbol;
            }
        }
    }
    if (isArray) {
        const array = value;
        for (const [index, value] of array.entries()) {
            const result = forEachDeep(value, iteratee, { _nameOrIndex: index, _objectOrArray: array });
            if (result === exports.breakSymbol) {
                return exports.breakSymbol;
            }
        }
    }
    return undefined;
}
exports.forEachDeep = forEachDeep;
function someDeep(value, predicate) {
    const result = forEachDeep(value, function (value) {
        return predicate(value) ? exports.breakSymbol : undefined;
    });
    return result === exports.breakSymbol;
}
exports.someDeep = someDeep;
function deleteUndefinedProperties(value) {
    forEachDeep(value, function (value, nameOrIndex, objectOrArray) {
        if (value === undefined &&
            nameOrIndex !== undefined &&
            objectOrArray !== undefined &&
            !Array.isArray(objectOrArray)) {
            delete objectOrArray[nameOrIndex];
        }
    });
    return value;
}
exports.deleteUndefinedProperties = deleteUndefinedProperties;
//# sourceMappingURL=object.js.map